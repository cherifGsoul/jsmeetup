/*!
 * CanJS - 2.3.0-pre.13
 * http://canjs.com/
 * Copyright (c) 2015 Bitovi
 * Wed, 23 Sep 2015 23:13:47 GMT
 * Licensed MIT
 */

/*can@2.3.0-pre.13#view/stache/mustache_core*/
define([
    'can/util/library',
    'can/view/utils',
    'can/view/mustache_helpers',
    'can/view/live',
    'can/elements',
    'can/view/scope',
    'can/view/node_lists'
], function (can, utils, mustacheHelpers, live, elements, Scope, nodeLists) {
    live = live || can.view.live;
    elements = elements || can.view.elements;
    Scope = Scope || can.view.Scope;
    nodeLists = nodeLists || can.view.nodeLists;
    var argumentsRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/~]+|[\(\)])/g, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/, mustacheLineBreakRegExp = /(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g, getItemsFragContent = function (items, isObserveList, helperOptions, options) {
            var frag = (can.document || can.global.document).createDocumentFragment();
            for (var i = 0, len = items.length; i < len; i++) {
                append(frag, helperOptions.fn(isObserveList ? items.attr('' + i) : items[i], options));
            }
            return frag;
        }, append = function (frag, content) {
            if (content) {
                frag.appendChild(typeof content === 'string' ? frag.ownerDocument.createTextNode(content) : content);
            }
        }, getItemsStringContent = function (items, isObserveList, helperOptions, options) {
            var txt = '';
            for (var i = 0, len = items.length; i < len; i++) {
                txt += helperOptions.fn(isObserveList ? items.attr('' + i) : items[i], options);
            }
            return txt;
        }, getKeyComputeData = function (key, scope, readOptions) {
            var data = scope.computeData(key, readOptions);
            can.compute.temporarilyBind(data.compute);
            return data;
        }, convertToScopes = function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer) {
            if (truthyRenderer) {
                helperOptions.fn = makeRendererConvertScopes(truthyRenderer, scope, options, nodeList);
            }
            if (falseyRenderer) {
                helperOptions.inverse = makeRendererConvertScopes(falseyRenderer, scope, options, nodeList);
            }
        }, makeRendererConvertScopes = function (renderer, parentScope, parentOptions, nodeList) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            return can.__notObserve(function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof can.view.Scope)) {
                    newScope = parentScope.add(newScope);
                }
                if (newOptions !== undefined && !(newOptions instanceof core.Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            });
        };
    var Expression = function (value) {
        this._value = value;
    };
    Expression.prototype.value = function () {
        return this._value;
    };
    var ScopeExpression = function (key) {
        this.key = key;
    };
    ScopeExpression.prototype = new Expression();
    ScopeExpression.prototype.value = function (scope, helperOptions, readOptions) {
        if (readOptions.asCompute) {
            var data = getKeyComputeData(this.key, scope, readOptions);
            if (!data.compute.computeInstance.hasDependencies) {
                return data.initialValue;
            } else {
                return data.compute;
            }
        } else {
            return scope.read(this.key, readOptions).value;
        }
    };
    var MethodExpression = function (name, args, hash) {
        this.name = name;
        this._args = args;
        this._hash = hash;
    };
    MethodExpression.prototype = new Expression();
    MethodExpression.prototype.args = function (scope, helperOptions, readOptions) {
        var args = [];
        for (var i = 0, len = this._args.length; i < len; i++) {
            var arg = this._args[i];
            args.push(arg.value.apply(arg, arguments));
        }
        return args;
    };
    MethodExpression.prototype.hash = function (scope, helperOptions, readOptions) {
        var hash = {};
        for (var prop in this._hash) {
            var val = this._hash[prop];
            hash[prop] = val.value.apply(val, arguments);
        }
        return hash;
    };
    MethodExpression.prototype.helperAndValue = function (scope, helperOptions, readOptions) {
        var looksLikeAHelper = this._args.length || !can.isEmptyObject(this._hash), helper, value, methodKey = this.name.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            var context = scope.attr('.');
            if (!helper && typeof context[methodKey] === 'function') {
                helper = { fn: context[methodKey] };
            }
        }
        if (!helper) {
            args = this.args(scope, helperOptions, readOptions);
            var computeData = getKeyComputeData(methodKey, scope, {
                    isArgument: false,
                    args: args && args.length ? args : [
                        scope.attr('.'),
                        scope
                    ]
                }), compute = computeData.compute;
            initialValue = computeData.initialValue;
            if (computeData.compute.computeInstance.hasDependencies) {
                value = compute;
            } else {
                value = initialValue;
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: value,
            args: args,
            helper: helper && helper.fn
        };
    };
    MethodExpression.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = {
                fn: function () {
                },
                inverse: function () {
                }
            }, context = scope.attr('.'), args = this.args(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer);
        can.simpleExtend(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args) || '';
        };
    };
    MethodExpression.prototype.value = function (scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions, readOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var compute = can.compute(fn);
        can.compute.temporarilyBind(compute);
        if (!compute.computeInstance.hasDependencies) {
            return compute();
        } else {
            return compute;
        }
    };
    var core = {
            Expression: Expression,
            ScopeExpression: ScopeExpression,
            MethodExpression: MethodExpression,
            expressionData: function (expression) {
                var tokens = this.expressionDataTokenize(expression);
                return this._expressionData(tokens, { index: 0 });
            },
            _expressionData: function (tokens, cursor) {
                var name;
                var args = [];
                var hashes = {};
                while (cursor.index < tokens.length) {
                    var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1], futureToken = tokens[cursor.index + 2];
                    if (token === '(') {
                        cursor.index++;
                        args.push(this._expressionData(tokens, cursor));
                    } else if (token === ')') {
                        cursor.index++;
                        return new MethodExpression(name, args, hashes);
                    } else if (nextToken === '=') {
                        cursor.index++;
                        cursor.index++;
                        cursor.index++;
                        if (futureToken === '(') {
                            hashes[token] = this._expressionData(tokens, cursor);
                        } else {
                            hashes[token] = literalRegExp.test(futureToken) ? new Expression(utils.jsonParse(futureToken)) : new ScopeExpression(futureToken);
                        }
                    } else {
                        cursor.index++;
                        if (name === undefined) {
                            name = new ScopeExpression(token);
                        } else {
                            args.push(literalRegExp.test(token) ? new Expression(utils.jsonParse(token)) : new ScopeExpression(token));
                        }
                    }
                }
                return new MethodExpression(name, args, hashes);
            },
            expressionDataTokenize: function (expression) {
                var tokens = [];
                (can.trim(expression) + ' ').replace(argumentsRegExp, function (whole, arg) {
                    tokens.push(arg);
                });
                return tokens;
            },
            makeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
                if (mode === '^') {
                    var temp = truthyRenderer;
                    truthyRenderer = falseyRenderer;
                    falseyRenderer = temp;
                }
                var readOptions = {
                        isArgument: true,
                        args: [
                            scope.attr('.'),
                            scope
                        ],
                        asCompute: true
                    };
                var helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                var helper = helperAndValue.helper;
                var value = helperAndValue.value;
                if (helper) {
                    return exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                }
                if (!mode) {
                    if (value && value.isComputed) {
                        return value;
                    } else {
                        return function () {
                            return '' + (value != null ? value : '');
                        };
                    }
                } else if (mode === '#' || mode === '^') {
                    var helperOptionArg = {
                            fn: function () {
                            },
                            inverse: function () {
                            }
                        };
                    convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer);
                    return function () {
                        var finalValue;
                        if (can.isFunction(value) && value.isComputed) {
                            finalValue = value();
                        } else {
                            finalValue = value;
                        }
                        if (utils.isArrayLike(finalValue)) {
                            var isObserveList = utils.isObserveLike(finalValue);
                            if (isObserveList ? finalValue.attr('length') : finalValue.length) {
                                return (stringOnly ? getItemsStringContent : getItemsFragContent)(finalValue, isObserveList, helperOptionArg, helperOptions);
                            } else {
                                return helperOptionArg.inverse(scope, helperOptions);
                            }
                        } else {
                            return finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
                        }
                    };
                } else {
                }
            },
            makeLiveBindingPartialRenderer: function (partialName, state) {
                partialName = can.trim(partialName);
                return function (scope, options, parentSectionNodeList) {
                    var nodeList = [this];
                    nodeList.expression = '>' + partialName;
                    nodeLists.register(nodeList, null, state.directlyNested ? parentSectionNodeList || true : true);
                    var partialFrag = can.compute(function () {
                            var localPartialName = partialName;
                            var partial = options.attr('partials.' + localPartialName), res;
                            if (partial) {
                                res = partial.render ? partial.render(scope, options) : partial(scope, options);
                            } else {
                                var scopePartialName = scope.read(localPartialName, {
                                        isArgument: true,
                                        returnObserveMethods: true,
                                        proxyMethods: false
                                    }).value;
                                if (scopePartialName === null) {
                                    return can.frag('');
                                }
                                if (scopePartialName) {
                                    localPartialName = scopePartialName;
                                }
                                res = can.isFunction(localPartialName) ? localPartialName(scope, options) : can.view.render(localPartialName, scope, options);
                            }
                            return can.frag(res);
                        });
                    live.html(this, partialFrag, this.parentNode, nodeList);
                };
            },
            makeStringBranchRenderer: function (mode, expression) {
                var exprData = core.expressionData(expression), fullExpression = mode + expression;
                return function branchRenderer(scope, options, truthyRenderer, falseyRenderer) {
                    var evaluator = scope.__cache[fullExpression];
                    if (mode || !evaluator) {
                        evaluator = makeEvaluator(scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                        if (!mode) {
                            scope.__cache[fullExpression] = evaluator;
                        }
                    }
                    var res = evaluator();
                    return res == null ? '' : '' + res;
                };
            },
            makeLiveBindingBranchRenderer: function (mode, expression, state) {
                var exprData = core.expressionData(expression);
                return function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                    var nodeList = [this];
                    nodeList.expression = expression;
                    nodeLists.register(nodeList, null, state.directlyNested ? parentSectionNodeList || true : true);
                    var evaluator = makeEvaluator(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, state.tag);
                    var compute = can.compute(evaluator, null, false);
                    compute.bind('change', can.k);
                    var value = compute();
                    if (typeof value === 'function') {
                        var old = can.__clearObserved();
                        value(this);
                        can.__setObserved(old);
                    } else if (compute.computeInstance.hasDependencies) {
                        if (state.attr) {
                            live.simpleAttribute(this, state.attr, compute);
                        } else if (state.tag) {
                            live.attributes(this, compute);
                        } else if (state.text && typeof value !== 'object') {
                            live.text(this, compute, this.parentNode, nodeList);
                        } else {
                            live.html(this, compute, this.parentNode, nodeList);
                        }
                    } else {
                        if (state.attr) {
                            can.attr.set(this, state.attr, value);
                        } else if (state.tag) {
                            live.setAttributes(this, value);
                        } else if (state.text && typeof value === 'string') {
                            this.nodeValue = value;
                        } else if (value) {
                            elements.replace([this], can.frag(value, this.ownerDocument));
                        }
                    }
                    compute.unbind('change', can.k);
                };
            },
            splitModeFromExpression: function (expression, state) {
                expression = can.trim(expression);
                var mode = expression.charAt(0);
                if ('#/{&^>!'.indexOf(mode) >= 0) {
                    expression = can.trim(expression.substr(1));
                } else {
                    mode = null;
                }
                if (mode === '{' && state.node) {
                    mode = null;
                }
                return {
                    mode: mode,
                    expression: expression
                };
            },
            cleanLineEndings: function (template) {
                return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                    spaceAfter = spaceAfter || '';
                    returnBefore = returnBefore || '';
                    spaceBefore = spaceBefore || '';
                    var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                    if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                        return whole;
                    } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                        return special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                    } else {
                        return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                    }
                });
            },
            Options: can.view.Scope.extend({
                init: function (data, parent) {
                    if (!data.helpers && !data.partials && !data.tags) {
                        data = { helpers: data };
                    }
                    can.view.Scope.prototype.init.apply(this, arguments);
                }
            })
        };
    var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
    can.view.mustacheCore = core;
    return core;
});