/*!
 * CanJS - 2.3.0-pre.13
 * http://canjs.com/
 * Copyright (c) 2015 Bitovi
 * Wed, 23 Sep 2015 23:13:47 GMT
 * Licensed MIT
 */

/*can@2.3.0-pre.13#view/scope/scope*/
var can = require('../../util/util.js');
var makeComputeData = require('./compute_data.js');
require('../../construct/construct.js');
require('../../map/map.js');
require('../../list/list.js');
require('../view.js');
require('../../compute/compute.js');
var escapeReg = /(\\)?\./g, escapeDotReg = /\\\./g, getNames = function (attr) {
        var names = [], last = 0;
        attr.replace(escapeReg, function (first, second, index) {
            if (!second) {
                names.push(attr.slice(last, index).replace(escapeDotReg, '.'));
                last = index + first.length;
            }
        });
        names.push(attr.slice(last).replace(escapeDotReg, '.'));
        return names;
    };
var Scope = can.Construct.extend({
        read: can.compute.read,
        Refs: can.Map.extend({}),
        Break: function () {
        },
        refsScope: function () {
            return new can.view.Scope(new this.Refs());
        }
    }, {
        init: function (context, parent, meta) {
            this._context = context;
            this._parent = parent;
            this.__cache = {};
            this._meta = meta || {};
        },
        attr: can.__notObserve(function (key, value, options) {
            options = can.simpleExtend({
                isArgument: true,
                returnObserveMethods: true,
                proxyMethods: false
            }, options);
            if (arguments.length === 2) {
                var lastIndex = key.lastIndexOf('.'), readKey = lastIndex !== -1 ? key.substring(0, lastIndex) : '.', obj = this.read(readKey, options).value;
                if (lastIndex !== -1) {
                    key = key.substring(lastIndex + 1, key.length);
                }
                can.compute.set(obj, key, value, options);
            } else {
                var res = this.read(key, options);
                return res.value;
            }
        }),
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        getRefs: function () {
            return this.getContext(function (scope) {
                return scope._context instanceof Scope.Refs;
            });
        },
        getViewModel: function () {
            return this.getContext(function (scope) {
                return scope._meta.viewModel;
            });
        },
        getContext: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope._context;
                }
                scope = scope._parent;
            }
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.push(context);
                scope = scope._parent;
            }
            if (parent) {
                can.each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (this._meta.protected) {
                return this._parent.read(attr, options);
            }
            var isInCurrentContext = attr.substr(0, 2) === './', isInParentContext = attr.substr(0, 3) === '../', isCurrentContext = attr === '.' || attr === 'this', isParentContext = attr === '..', isContextBased = isInCurrentContext || isInParentContext || isCurrentContext || isParentContext;
            if (isContextBased && this._meta.notContext) {
                return this._parent.read(attr, options);
            }
            var stopLookup;
            if (isInCurrentContext) {
                stopLookup = true;
                attr = attr.substr(2);
            } else if (isInParentContext) {
                return this._parent.read(attr.substr(3), options);
            } else if (isCurrentContext) {
                return { value: this._context };
            } else if (isParentContext) {
                return { value: this._parent._context };
            } else if (attr === '@root') {
                return { value: this.getRoot() };
            }
            var names = attr.indexOf('\\.') === -1 ? attr.split('.') : getNames(attr), context, scope = this, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, searchedRefsScope = false, refInstance, readOptions = can.simpleExtend({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = names.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            while (scope) {
                context = scope._context;
                refInstance = context instanceof Scope.Refs;
                if (context !== null && (typeof context === 'object' || typeof context === 'function') && !(searchedRefsScope && refInstance) && !scope._meta.protected) {
                    if (refInstance) {
                        searchedRefsScope = true;
                    }
                    var data = can.compute.read(context, names, readOptions);
                    if (data.value !== undefined) {
                        return {
                            scope: scope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push(can.__clearObserved());
                    }
                }
                if (!stopLookup) {
                    scope = scope._parent;
                } else {
                    scope = null;
                }
            }
            var len = undefinedObserves.length;
            if (len) {
                for (var i = 0; i < len; i++) {
                    can.__addObserved(undefinedObserves[i]);
                }
            }
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        }
    });
can.view.Scope = Scope;
module.exports = Scope;